xy_grid <- data.frame(Var1=nc_data$dim$longitude$vals[longlat_index[,1]], Var2=nc_data$dim$latitude$vals[longlat_index[,2]])
}else if(study_region=="(e)East"){
#AllNA3==4
longlat_index <- which(AllNA3==4, arr.ind=TRUE)
long_index <- unique(longlat_index[,1])
lat_index <- unique(longlat_index[,2])
xy_grid <- data.frame(Var1=nc_data$dim$longitude$vals[longlat_index[,1]], Var2=nc_data$dim$latitude$vals[longlat_index[,2]])
}else if(study_region=="(f)Northern"){
#AllNA3==3
longlat_index <- which(AllNA3==3, arr.ind=TRUE)
long_index <- unique(longlat_index[,1])
lat_index <- unique(longlat_index[,2])
xy_grid <- data.frame(Var1=nc_data$dim$longitude$vals[longlat_index[,1]], Var2=nc_data$dim$latitude$vals[longlat_index[,2]])
}
central_index <- which(apply(longlat_index, 1, function(x) all(round(apply(longlat_index, 2, median))==x)))
plot.divisor <- 1
if(subsetting==TRUE & !(study_region %in% c("(b)Palliser", "(c)BC"))){
#coaser scale
divisor <- sum(longlat_index[central_index,])%%2
subset_index <- which(apply(longlat_index, 1, function(x) sum(x)%%2) == divisor)
longlat_index <- longlat_index[subset_index,]
long_index <- unique(longlat_index[,1])
lat_index <- unique(longlat_index[,2])
xy_grid <- data.frame(Var1=nc_data$dim$longitude$vals[longlat_index[,1]], Var2=nc_data$dim$latitude$vals[longlat_index[,2]])
central_index <- which(apply(longlat_index, 1, function(x) all(round(apply(longlat_index, 2, median))==x)))
plot.divisor <- 2
}
result_dataset <- c()
CANGRD_dataset <- c()
for(i in 1:nrow(xy_grid)){
x_ind <- match(xy_grid[i,1], as.numeric(dimnames(ndvi.array.annual)[[1]]))
y_ind <- match(xy_grid[i,2], as.numeric(dimnames(ndvi.array.annual)[[2]]))
new_col <- matrix(ndvi.array.choice[x_ind,y_ind,1,], ncol=1)
colnames(new_col)[1] <- paste(xy_grid[i,1], xy_grid[i,2], sep="=")
result_dataset <- cbind(result_dataset, new_col)
CANGRD_col <- matrix(CANGRD.array.choice[x_ind,y_ind,1,], ncol=1)
colnames(CANGRD_col)[1] <- paste(xy_grid[i,1], xy_grid[i,2], sep="=")
CANGRD_dataset <- cbind(CANGRD_dataset, CANGRD_col)
}
central_name <- colnames(result_dataset)[central_index]
########################################
#August 26, 2020: central_index 고르기: .9? return level을 구해서 가장 큰 쪽으로 하자
########################################
change_central=TRUE
if(change_central==TRUE){
dist_min <- min(dist(xy_grid))
central_cand <- which(apply(as.matrix(dist(xy_grid)), 1, function(x) sum(x==dist_min))==4)
#paste(dimnames(ndvi.array.annual)[[1]][43], dimnames(ndvi.array.annual)[[2]][12], sep="=") "-108=51"
compute_gpdRl <- function(x){
fit <- eva::gpdFit(as.numeric(x), threshold=quantile(as.numeric(x), prob=0.7))
gpdRl(fit, period=10, method="delta")$Estimate
}
#central_ind_cand <- strsplit(names(which.max(apply(result_dataset, 2, compute_gpdRl))), split="=")
central_index <- intersect(order(apply(result_dataset, 2, compute_gpdRl), decreasing=TRUE), central_cand)[1]
}
central_name <- colnames(result_dataset)[central_index]
########################################
#(끝) August 26, 2020: central_index 고르기: .9? return level을 구해서 가장 큰 쪽으로 하자
########################################
migpd_obj <- migpd(result_dataset, mqu=0.7)
mexDep_imsi <- mexDependence(x=migpd_obj, which=central_name , dqu=0.7)
CANGRD_obj <- migpd(CANGRD_dataset[-c(1:98),], mth=apply(CANGRD_dataset, 2, quantile, prob=0.7, na.rm=T))
CANGRD_mexDep_imsi <- mexDependence(x=migpd_obj, which=central_name , dqu=0.7)
#boot_imsi <- bootmex(mexDep_imsi)
########################################
#Step 3-(b) when there are more than one unconditional variables (two, three, ...)
########################################
#xy_index_conditional <- c(long_index[5], lat_index, 1)
#xy_index_unconditional <- cbind(long_index[-5], lat_index, 1)
xy_index_conditional <- c(longlat_index[central_index,1], longlat_index[central_index,2], 1)
xy_index_unconditional <- cbind(longlat_index[-central_index,1], longlat_index[-central_index,2], 1)
u <- u.array.choice[xy_index_conditional[1], xy_index_conditional[2], xy_index_conditional[3],]
##data
Y <- mexDep_imsi$margins$transformed
#data_likelihoo의 Inf 처리 필요
#extreme_index <- which(Y[xy_index_conditional[1], xy_index_conditional[2], xy_index_conditional[3],] > u) #approximately 120
extreme_index <- which(Y[,central_index] > u) #approximately 120
data_likelihood <- data.frame(X00=Y[extreme_index, central_index])
for(i in 1:nrow(longlat_index)){
if(i!=central_index){
data_frame_imsi <- data.frame(Y[extreme_index,i])
names(data_frame_imsi) <- paste("X1", i, sep="")
data_likelihood <- cbind(data_likelihood, data_frame_imsi)
#data_likelihood <- cbind(data_likelihood, paste("X1", i, sep="")=Y[xy_index_unconditional[i,1], xy_index_unconditional[i,2], xy_index_unconditional[i,3],extreme_index])
}
}
data <- data_likelihood #for the test purpose
library(Kendall)
Kendall_tau <- c()
for(i in 1:(ncol(data)-1)){
Kendall_tau <- c(Kendall_tau, Kendall(data$X00, data[,(i+1)])$tau[1])
}
par(mfrow=c(2,2))
Kendall(data$X00, data$X11)
hist(data$X11)
hist(data$X12)
hist(data$X13)
hist(data$X14)
########################################
#Step 4: a(h), b(h), mu(h), sigma(h) estimation step
########################################
nonlinear_estimation_obj <- nonlinear_estimation(mexDepobj=mexDep_imsi, xy_grid=xy_grid)
#mexDepobj=mexDep_imsi
########################################
#Step 5: estimation
########################################
##initial values
margins_L <- list( p2q = function(p)ifelse(p < .5, log(2 * p), -log(2 * (1 - p))),
q2p = function(q)ifelse(q < 0, exp(q)/2, 1- 0.5*exp(-q)))
#(SC): there is an R cod mexTransform.R, default method: mixture
#(Apr 17) 아마도 Gumbel 또는 Laplace 마진에 맞추어 x(data)를 바꾸는 함수인듯
x_tr <- mexTransform(migpd_obj, margins = margins_L, method = "mixture", r=NULL) #(SC) marginal transform!
dqu <- 0.7
dth <- quantile(x_tr$transformed[, central_index], dqu) #(SC) if dqu=0.7, it computes 70% quatile
yex <- c(x_tr$transformed[, central_index])
wh <- yex > unique(dth)
#additionally,
#phi in (1,2)
ne <- nonlinear_estimation_obj
ev <- 0.0001
#init.lower <- as.numeric(c(nonlinear_estimation_obj$pars-ev, 0.1, sqrt(2), 0.5,1,0.901,0.01))
#init.upper <- as.numeric(c(nonlinear_estimation_obj$pars+ev, 2, 2, 0.7,2,1.124,2*pi))
init.lower <- as.numeric(c(nonlinear_estimation_obj$pars-ev, 0.1, sqrt(2), 0.5,1,0.5,-1))
init.upper <- as.numeric(c(nonlinear_estimation_obj$pars+ev, 2, 2, 0.7,2,2,1))
par.names <- c(names(nonlinear_estimation_obj$pars), "rho", "phi", "delta1", "delta2", "Stretch", "Angle")
par.lower <- as.numeric(c(rep(0.0001, length(nonlinear_estimation_obj$pars)), 0.5, 1, 0.01, -Inf,0.5,-1))
par.upper <- as.numeric(c(rep(Inf, length(nonlinear_estimation_obj$pars)), 0.99, 2, Inf, Inf,2,1))
if("sigm"%in%par.names){
par.lower[which(par.names=="sigm")] <- 0.2
}
#init.lower <- c(1, 8, 0.4, 0.1, sqrt(2), 0.9,-0.2,0.5,1,0.9,0.01)
#init.upper <- c(2.5, 49, 1, 2, 2, 1.2,0.2,0.7,2,1.2,2*pi)
#init.lower <- c(ne$kapp-ev, ne$lambda-ev, ne$bet-ev, ne$bet_KS1-ev, ne$bet_KS2-ev, 0.1, sqrt(2), ne$sigm-ev, ne$sigm_KS1-ev, ne$sigm_KS2-ev, ne$mu-ev, ne$mu_KS1-ev, ne$mu_KS2-ev, ne$mu_KS3-ev, 0.5,1,0.8,0.01)
#init.upper <- c(ne$kapp+ev, ne$lambda+ev, ne$bet+ev, ne$bet_KS1+ev, ne$bet_KS2+ev, 2, 2, ne$sigm+ev, ne$sigm_KS1+ev, ne$sigm_KS2+ev, ne$mu+ev, ne$mu_KS1+ev, ne$mu_KS2+ev, ne$mu_KS3+ev, 0.7,2,1.2,2*pi)
#par.names <- c("kapp", "lambda", "bet", "bet_KS1", "bet_KS2", "rho", "phi", "sigm", "sigm_KS1", "sigm_KS2", "mu", "mu_KS1", "mu_KS2", "mu_KS3", "delta1", "delta2", "Stretch", "Angle")
#par.lower <- c(0.01, 0.01, -1, 0.5, 1, 0.5, -1.2, 0.01, -Inf,0.8,0.01)
#par.upper <- c(Inf, Inf, 1, 0.99, 2, 1,2, 1.2, Inf, Inf,1.1,2*pi)
#par.lower <- c(ne$kapp-ev, ne$lambda-ev, ne$bet-ev, ne$bet_KS1-ev, ne$bet_KS2-ev, 0.5, 1, ne$sigm-ev, ne$sigm_KS1-ev, ne$sigm_KS2-ev, ne$mu-ev, ne$mu_KS1-ev, ne$mu_KS2-ev, ne$mu_KS3-ev, 0.01, -Inf,0.8,0.01)
#par.upper <- c(ne$kapp+ev, ne$lambda+ev, ne$bet+ev, ne$bet_KS1+ev, ne$bet_KS2+ev, 0.99, 2, ne$sigm+ev, ne$sigm_KS1+ev, ne$sigm_KS2+ev, ne$mu+ev, ne$mu_KS1+ev, ne$mu_KS2+ev, ne$mu_KS3+ev, Inf, Inf,1.2,2*pi)
known.par <- rep(NA, length(par.names))#; known.par[1] <- 1
#known.par <-  c(ne$kapp, ne$lambda, ne$bet, ne$bet_KS1, ne$bet_KS2, NA, NA, ne$sigm, ne$sigm_KS1, ne$sigm_KS2, ne$mu, ne$mu_KS1, ne$mu_KS2, ne$mu_KS3, NA, NA, NA ,NA)
aniso <- FALSE
aniso <- TRUE
global.min <- 0
tol <- 1e-2
time_init <- Sys.time()
#(8개를 넣는다면) 순서대로 "kapp", "lambda", "bet", "rho", "sigm", "mu", "delta1", "delta2"
#(9개를 넣는다면) 순서대로 "kapp", "lambda", "bet", "rho", "sigm_KS1", "sigm_KS2", "mu", "delta1", "delta2"
param_init2 <- GenSA(lower=init.lower, upper=init.upper,
fn= composite_likelihood_parallel,
par.names=par.names, known.par=known.par,
data=x_tr$transformed[wh,], xy_grid=xy_grid, spatialmethod="Shooter", aniso=aniso, xy_grid_cond_index=central_index, modelbeta="SC", addsigma=TRUE,verbose=FALSE,
control=list(threshold.stop=global.min+tol, max.time=60, maxit=30))
param2 <- matrix(param_init2$par,nrow=1)
colnames(param2) <- par.names
composite_likelihood_parallel(par=param2, data=x_tr$transformed[wh,], xy_grid=xy_grid,par.names=par.names, known.par=known.par,
spatialmethod="Shooter", aniso=aniso, xy_grid_cond_index=central_index, modelbeta="SC", addsigma=TRUE,verbose=FALSE)
mexDep_spatial_obj <- mexDependence_spatial(x=migpd_obj, which=central_name , dqu=0.7, xy_grid=xy_grid, start=param2,
par.lower=par.lower, par.upper=par.upper,
par.names=par.names, modelbeta="SC", addsigma=TRUE, verbose=FALSE,
known.par=known.par, spatialmethod="Shooter", aniso=aniso, nonlinear.obj = ne, skip.opt=TRUE)
#x=migpd_obj; which=central_name; dqu=0.7; xy_grid; start=param2
#par.names=c("kapp", "lambda", "bet", "rho", "sigm", "mu", "delta1", "delta2"); known.par=c(NA,NA,NA,NA,NA,NA,NA,NA);  par.lower=c(0.01, 0.01, 0, 0, 0.5, -Inf, 0.01, -Inf); par.upper=c(Inf, Inf, 0.99, 0.99, Inf, Inf, Inf, Inf)
#spatialmethod="Shooter"; aniso=FALSE; addsigma=TRUE; modelbeta="SC"
#margins = "laplace"; constrain=FALSE; v = 10; maxit=1000000; nOptim = 1; marTransform="mixture"; referenceMargin=NULL
#PlotLikDo=FALSE; xy_grid_cond_index=NULL; model="Shooter"; use.supp=TRUE; use.initial=FALSE; use.tapering=TRUE; verbose=TRUE
if(abs(mexDep_spatial_obj$dependence$loglik)>1000000){
mexDep_spatial_obj$dependence$coefficients <- as.matrix(param_init2$par, ncol=1)
rownames(mexDep_spatial_obj$dependence$coefficients) <- par.names
}
########################################
#Step 6: prediction
########################################
#mexDep_spatial_obj_pred <- predict.mexspatial(mexDep_spatial_obj, smoothZdistribution=TRUE)
mexDep_spatial_obj_pred <- predict.mexspatial(mexDep_spatial_obj, pqu=0.71, maxpqu=0.99, predmodel="Shooter")# default
#object <- mexDep_spatial_obj; pqu=0.79; maxpqu=0.81; predmodel="Shooter"; throwdist="unif"; nsim = 1000; smoothZdistribution=FALSE
mexDep_spatial_obj_pred_8 <- predict.mexspatial(mexDep_spatial_obj, pqu=0.79, maxpqu=0.81, predmodel="Shooter")# default
mexDep_spatial_obj_pred_9 <- predict.mexspatial(mexDep_spatial_obj, pqu=0.89, maxpqu=0.91, predmodel="Shooter")# default
mexDep_spatial_obj_pred_95 <- predict.mexspatial(mexDep_spatial_obj, pqu=0.94, maxpqu=0.96, predmodel="Shooter")# defaultmexDep_spatial_obj_pred_95 <- predict.mexspatial(mexDep_spatial_obj, pqu=0.94, maxpqu=0.96)# default
mexDep_spatial_obj_pred_99 <- predict.mexspatial(mexDep_spatial_obj, pqu=0.985, maxpqu=0.995, predmodel="Shooter")# default
pred_val_8 <- apply(mexDep_spatial_obj_pred_8$data$simulated, 2, mean)
pred_val_9 <- apply(mexDep_spatial_obj_pred_9$data$simulated, 2, mean)
pred_val_95 <- apply(mexDep_spatial_obj_pred_95$data$simulated, 2, mean)
pred_val_99 <- apply(mexDep_spatial_obj_pred_99$data$simulated, 2, mean)
pred_val_8 <- pred_val_8[match(colnames(mexDep_spatial_obj$margins$data), names(pred_val_8))]
pred_val_9 <- pred_val_9[match(colnames(mexDep_spatial_obj$margins$data), names(pred_val_9))]
pred_val_95 <- pred_val_95[match(colnames(mexDep_spatial_obj$margins$data), names(pred_val_95))]
pred_val_99 <- pred_val_99[match(colnames(mexDep_spatial_obj$margins$data), names(pred_val_99))]
xy_expand <- expand.grid(nc_data$dim$longitude$vals, nc_data$dim$latitude$vals)
par(mar=c(4.1,5.1,3.1,3.1))
par(mfrow=c(2,2))
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(a) Nonlinear, 0.8q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_8, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
points(xy_grid[central_index,1], xy_grid[central_index,2], pch=0)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(b) Nonlinear, 0.9q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_9, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(c) Nonlinear, 0.95q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_95, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(d) Nonlinear, 0.99q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_99, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
#(비교용)
mexDep_imsi_pred <- modifiedpredict.mex(mexDep_imsi , pqu=0.99)# default
mexDep_imsi_pred <- modifiedpredict.mex(mexDep_imsi , pqu=0.7)# default
mexDep_imsi_pred <- modifiedpredict.mex(mexDep_imsi , pqu=0.7, maxpqu=0.71)# default
g <- ggplot(mexDep_imsi_pred ,plot.=FALSE)
g[[1]]
mexDep_imsi_pred_8 <- modifiedpredict.mex(mexDep_imsi , pqu=0.79, maxpqu=0.81)# default
mexDep_imsi_pred_9 <- modifiedpredict.mex(mexDep_imsi , pqu=0.89, maxpqu=0.91)# default
mexDep_imsi_pred_95 <- modifiedpredict.mex(mexDep_imsi , pqu=0.94, maxpqu=0.96)# defaultmexDep_imsi_pred_95 <- predict.mexspatial(mexDep_imsi_pred , pqu=0.94, maxpqu=0.96)# default
mexDep_imsi_pred_99 <- modifiedpredict.mex(mexDep_imsi , pqu=0.985, maxpqu=0.995)# default
#simulated: 그냥 값
#transformed: (Laplace) marginal transform을 했을 때의 값
pred_val_8_m <- apply(mexDep_imsi_pred_8$data$simulated, 2, mean)
pred_val_9_m <- apply(mexDep_imsi_pred_9$data$simulated, 2, mean)
pred_val_95_m <- apply(mexDep_imsi_pred_95$data$simulated, 2, mean)
pred_val_99_m <- apply(mexDep_imsi_pred_99$data$simulated, 2, mean)
pred_val_8_m <- pred_val_8_m[match(colnames(mexDep_imsi$margins$data), names(pred_val_8_m))]
pred_val_9_m <- pred_val_9_m[match(colnames(mexDep_imsi$margins$data), names(pred_val_9_m))]
pred_val_95_m <- pred_val_95_m[match(colnames(mexDep_imsi$margins$data), names(pred_val_95_m))]
pred_val_99_m <- pred_val_99_m[match(colnames(mexDep_imsi$margins$data), names(pred_val_99_m))]
par(mar=c(4.1,5.1,3.1,3.1))
par(mfrow=c(2,2))
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(a) H-T, 0.8q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_8_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(b) H-T, 0.9q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_9_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(c) H-T, 0.95q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_95_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(d) H-T, 0.99q")
quilt.plot(xy_grid[,1], xy_grid[,2], pred_val_99_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
#(비교용)
CANGRD_mexDep_imsi_pred <- modifiedpredict.mex(CANGRD_mexDep_imsi , pqu=0.99)# default
CANGRD_mexDep_imsi_pred <- modifiedpredict.mex(CANGRD_mexDep_imsi , pqu=0.7)# default
CANGRD_mexDep_imsi_pred <- modifiedpredict.mex(CANGRD_mexDep_imsi , pqu=0.7, maxpqu=0.71)# default
g <- ggplot(CANGRD_mexDep_imsi_pred ,plot.=FALSE)
g[[1]]
CANGRD_mexDep_imsi_pred_8 <- modifiedpredict.mex(CANGRD_mexDep_imsi , pqu=0.79, maxpqu=0.81)# default
CANGRD_mexDep_imsi_pred_9 <- modifiedpredict.mex(CANGRD_mexDep_imsi , pqu=0.89, maxpqu=0.91)# default
CANGRD_mexDep_imsi_pred_95 <- modifiedpredict.mex(CANGRD_mexDep_imsi , pqu=0.94, maxpqu=0.96)# defaultmexDep_imsi_pred_95 <- predict.mexspatial(mexDep_imsi_pred , pqu=0.94, maxpqu=0.96)# default
CANGRD_mexDep_imsi_pred_99 <- modifiedpredict.mex(CANGRD_mexDep_imsi , pqu=0.985, maxpqu=0.995)# default
#simulated: 그냥 값
#transformed: (Laplace) marginal transform을 했을 때의 값
CANGRD_pred_val_8_m <- apply(CANGRD_mexDep_imsi_pred_8$data$simulated, 2, mean)
CANGRD_pred_val_9_m <- apply(CANGRD_mexDep_imsi_pred_9$data$simulated, 2, mean)
CANGRD_pred_val_95_m <- apply(CANGRD_mexDep_imsi_pred_95$data$simulated, 2, mean)
CANGRD_pred_val_99_m <- apply(CANGRD_mexDep_imsi_pred_99$data$simulated, 2, mean)
CANGRD_pred_val_8_m <- CANGRD_pred_val_8_m[match(colnames(CANGRD_mexDep_imsi$margins$data), names(CANGRD_pred_val_8_m))]
CANGRD_pred_val_9_m <- CANGRD_pred_val_9_m[match(colnames(CANGRD_mexDep_imsi$margins$data), names(CANGRD_pred_val_9_m))]
CANGRD_pred_val_95_m <- CANGRD_pred_val_95_m[match(colnames(CANGRD_mexDep_imsi$margins$data), names(CANGRD_pred_val_95_m))]
CANGRD_pred_val_99_m <- CANGRD_pred_val_99_m[match(colnames(CANGRD_mexDep_imsi$margins$data), names(CANGRD_pred_val_99_m))]
par(mar=c(4.1,5.1,3.1,3.1))
par(mfrow=c(2,2))
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(a) CANGRD, 0.8q")
quilt.plot(xy_grid[,1], xy_grid[,2], CANGRD_pred_val_8_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(b) CANGRD, 0.9q")
quilt.plot(xy_grid[,1], xy_grid[,2], CANGRD_pred_val_9_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(c) CANGRD, 0.95q")
quilt.plot(xy_grid[,1], xy_grid[,2], CANGRD_pred_val_95_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(d) CANGRD, 0.99q")
quilt.plot(xy_grid[,1], xy_grid[,2], CANGRD_pred_val_99_m, add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
##Question: empirical qunatiles
#migpd_obj$data
#or x_transformed
#par(mar=c(4.1,5.1,3.1,3.1))
#par(mfrow=c(2,2))
#
#index.08 <- order(abs(x_tr$transformed[,central_index]-quantile(x_tr$transformed[,central_index], prob=0.8)))[c(1:5)]
#index.09 <- order(abs(x_tr$transformed[,central_index]-quantile(x_tr$transformed[,central_index], prob=0.9)))[c(1:5)]
#index.095 <- order(abs(x_tr$transformed[,central_index]-quantile(x_tr$transformed[,central_index], prob=0.95)))[c(1:5)]
#index.099 <- order(abs(x_tr$transformed[,central_index]-quantile(x_tr$transformed[,central_index], prob=0.99)))[c(1:5)]
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(a) Raw, 0.8q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(migpd_obj$data[index.08,]), add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(b) Raw, 0.9q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(migpd_obj$data[index.09,]), add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(c) Raw, 0.95q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(migpd_obj$data[index.095,]), add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(d) Raw, 0.99q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(migpd_obj$data[index.099,]), add=T, nx=length(unique(xy_grid[,1]))/plot.divisor, ny=length(unique(xy_grid[,2]))/plot.divisor)
#par(mar=c(4.1,5.1,3.1,3.1))
#par(mfrow=c(2,2))
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(a) Raw, 0.8q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(x_tr$transformed[index.08,]), add=T, nx=15, ny=4)
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(b) Raw, 0.9q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(x_tr$transformed[index.09,]), add=T, nx=15, ny=4)
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(c) Raw, 0.95q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(x_tr$transformed[index.095,]), add=T, nx=15, ny=4)
#
#quilt.plot(xy_expand, as.vector(AllNA), nx=101, ny=46, add.legend = FALSE, xlab="Lon", ylab="Lat",col = gray.colors(3), main="(d) Raw, 0.99q")
#quilt.plot(xy_grid[,1], xy_grid[,2], colMeans(x_tr$transformed[index.099,]), add=T, nx=15, ny=4)
## additional parameter plot
par(mar=c(5.1,4.1,4.1,2.1)/1)
par(mfrow=c(2,3))
#parameter comparison
#(SC) h function
xy_grid_old <- xy_grid
#h_pairwise_vec <- sqrt((xy_grid_old$Var1[-central_index] - xy_grid_old$Var1[central_index])^2
#                       + (xy_grid_old$Var2[-central_index] - xy_grid_old$Var2[central_index])^2)
h_pairwise_vec <- distGeo(xy_grid_old[-central_index,], xy_grid_old[central_index,])/70000
#h_seq <- h_pairwise_vec
dcoobj <- mexDep_spatial_obj
#dcoobj <- mexDep_spatial_obj_model2
dco <- dcoobj$dependence$coefficients
par.names <- rownames(dco)
for(k in 1:length(par.names)){
assign(rownames(dco)[k], dco[k])
}
if(!("phi" %in% par.names)){
phi <- NULL
}
if(dcoobj$dependence$aniso==TRUE){
Stretch <- dcoobj$dependence$coefficients[which(par.names=="Stretch"),]
Angle <- dcoobj$dependence$coefficients[which(par.names=="Angle"),]
#coordinat transform
xy_grid <- compute_aniso(xy_grid, Angle=Angle, Stretch=Stretch)
}else{
xy_grid <- xy_grid_old
}
#h_new <- sqrt((xy_grid$Var1[-central_index] - xy_grid$Var1[central_index])^2
#              + (xy_grid$Var2[-central_index] - xy_grid$Var2[central_index])^2)
h_new <- distGeo(xy_grid[-central_index,], xy_grid[central_index,])/70000
h_seq<- seq(0, max(h_pairwise_vec), length.out = 100)
alpha_y <- as.numeric(mexDep_imsi$dependence$coefficients[1,])
if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha=="W1.2"){
plot(h_pairwise_vec, alpha_y, pch=16, col="gray", main=expression(paste("(a) ", alpha ,"(h)")), xlab="h", ylab=expression(paste(alpha, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(alpha_y), max(1, max(alpha_y))))
lines(h_seq, (exp(-(h_seq/lambda)^kapp)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha=="W1.4"){
plot(h_pairwise_vec, alpha_y, pch=16, col="gray", main=expression(paste("(a) ", alpha ,"(h)")), xlab="h", ylab=expression(paste(alpha, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(alpha_y), max(1, max(alpha_y))))
lines(h_seq, alpha_KS3 + (1-alpha_KS3)*(exp(-(h_seq/lambda)^kapp)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha=="Const"){
plot(h_pairwise_vec, alpha_y, pch=16, col="gray", main=expression(paste("(a) ", alpha ,"(h)")), xlab="h", ylab=expression(paste(alpha, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(alpha_y), max(1, max(alpha_y))))
lines(h_seq, rep(alpha, length(h_seq)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha=="W1.3piecewise"){
plot(h_pairwise_vec, alpha_y, pch=16, col="gray", main=expression(paste("(a) ", alpha ,"(h)")), xlab="h", ylab=expression(paste(alpha, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(alpha_y), max(1, max(alpha_y))))
lines(h_seq, alpha*(exp(-(h_seq/lambda)^kapp)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha=="W1.4piecewise"){
plot(h_pairwise_vec, alpha_y, pch=16, col="gray", main=expression(paste("(a) ", alpha ,"(h)")), xlab="h", ylab=expression(paste(alpha, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(alpha_y), max(1, max(alpha_y))))
lines(h_seq, alpha_KS3+(alpha-alpha_KS3)*(exp(-(h_seq/lambda)^kapp)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha=="EXD.2"){
plot(h_pairwise_vec, alpha_y, pch=16, col="gray", main=expression(paste("(a) ", alpha ,"(h)")), xlab="h", ylab=expression(paste(alpha, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(alpha_y), max(1, max(alpha_y))))
lines(h_seq, alpha*(exp(-(h_seq/lambda))), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha=="EXD.3"){
plot(h_pairwise_vec, alpha_y, pch=16, col="gray", main=expression(paste("(a) ", alpha ,"(h)")), xlab="h", ylab=expression(paste(alpha, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(alpha_y), max(1, max(alpha_y))))
lines(h_seq, alpha_KS3+(alpha-alpha_KS3)*(exp(-(h_seq/lambda))), col="blue")
}
bet_y <- as.numeric(mexDep_imsi$dependence$coefficients[2,])
if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_bet=="Const"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[2,]), pch=16, col="gray", main=expression(paste("(b) ", beta ,"(h)")), xlab="h", ylab=expression(paste(beta, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(bet_y), max(1, max(bet_y))))
lines(h_seq, rep(bet, length(h_seq)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_bet=="W1.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[2,]), pch=16, col="gray", main=expression(paste("(b) ", beta ,"(h)")), xlab="h", ylab=expression(paste(beta, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(bet_y), max(1, max(bet_y))))
lines(h_seq, (exp(-(h_seq/bet_KS2)^bet_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_bet=="W2.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[2,]), pch=16, col="gray", main=expression(paste("(b) ", beta ,"(h)")), xlab="h", ylab=expression(paste(beta, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(bet_y), max(1, max(bet_y))))
lines(h_seq, (1 - exp(-(h_seq/bet_KS2)^bet_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_bet=="EXD.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[2,]), pch=16, col="gray", main=expression(paste("(b) ", beta ,"(h)")), xlab="h", ylab=expression(paste(beta, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(min(bet_y), max(1, max(bet_y))))
lines(h_seq, (bet*exp(-(h_seq/bet_KS2))), col="blue")
}
sigm_y <- mexDep_imsi$dependence$coefficients[6,]
if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_sigm=="Const"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[6,]), pch=16, col="gray", main=expression(paste("(c) ", sigma ,"(h)")), xlab="h", ylab=expression(paste(sigma, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(0,1.5))
lines(h_seq, rep(sigm, length(h_seq)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_sigm=="W2.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[6,]), pch=16, col="gray", main=expression(paste("(c) ", sigma ,"(h)")), xlab="h", ylab=expression(paste(sigma, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(0,1.5))
lines(h_seq, (1 - exp(-(h_seq/sigm_KS2)^sigm_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_sigm=="W2.3"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[6,]), pch=16, col="gray", main=expression(paste("(c) ", sigma ,"(h)")), xlab="h", ylab=expression(paste(sigma, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(0,1.5))
lines(h_seq, sigm*(1 - exp(-(h_seq/sigm_KS2)^sigm_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_sigm=="AR.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[6,]), pch=16, col="gray", main=expression(paste("(c) ", sigma ,"(h)")), xlab="h", ylab=expression(paste(sigma, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)), ylim=c(0,1.5))
lines(h_seq, sigm*(1-exp(-(h_seq/sigm_KS2))), col="blue")
}
mu_y <- mexDep_imsi$dependence$coefficients[5,]
if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="Const"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, rep(mu, length(h_seq)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="W1.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, (exp(-(h_seq/mu_KS2)^mu_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="W1.3"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu*(exp(-(h_seq/mu_KS2)^mu_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="W1.4"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu_KS3+(mu-mu_KS3)*(exp(-(h_seq/mu_KS2)^mu_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="W2.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, (1-exp(-(h_seq/mu_KS2)^mu_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="W2.3"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu*(1-exp(-(h_seq/mu_KS2)^mu_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="W2.4"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu_KS3+(mu-mu_KS3)*(1-exp(-(h_seq/mu_KS2)^mu_KS1)), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="EXD.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu*(exp(-(h_seq/mu_KS2))), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="EXD.3"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu_KS3 + (mu-mu_KS3)*(exp(-(h_seq/mu_KS2))), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="AR.2"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu*(1-exp(-(h_seq/mu_KS2))), col="blue")
}else if(mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu=="AR.3"){
plot(h_pairwise_vec, as.numeric(mexDep_imsi$dependence$coefficients[5,]), pch=16, col="gray", main=expression(paste("(d) ", mu ,"(h)")), xlab="h", ylab=expression(paste(mu, "(h)")), cex.main=1.5, xlim=c(0, max(h_pairwise_vec)))
lines(h_seq, mu_KS3 + (mu-mu_KS3)*(1-exp(-(h_seq/mu_KS2))), col="blue")
}
plot(h_seq, 1 + exp(-(h_seq/delta1)^(delta2)) , col="blue", type="l", main=expression(paste("(e) ", delta ,"(h)")), xlab="h", ylab=expression(paste(delta, "(h)")), cex.main=1.5)
#points(h_new, 1 + exp(-(h_new/delta1)^(delta2)), pch=16, col="gray")
plot(h_seq, exp(-h_seq/rho) , type="l", col="blue", main=expression(paste("(f) ", rho ,"(h)")), xlab="h", ylab=expression(paste(rho, "(h)")), cex.main=1.5)
#points(h_new, exp(-h_new/rho), pch=16, col="gray")
# install.packages("remotes")
remotes::install_github("fmmattioni/downloadthis")
##save object
saveobj <- TRUE
if(saveobj==TRUE){
#include: study_region
#include: model_name (study_model)
#include: mqu (dqu)
newdqu <- as.integer(10*dqu)
#include: pqu (그냥 다 포함, list 원소로)
#include: conditioning station (central_index)
#include: method (그냥 다 포함, list 원소로)
period <- "Summer-Autumn"
save_name <- paste(study_region, period, study_model, newdqu, central_index, sep="_")
save_list <- list()
save_list$study_region <- study_region
save_list$study_model <- study_model
save_list$dqu <- dqu
save_list$central_index <- central_index
save_list$xy_grid <- xy_grid_old
#save_list$xy_grid_new <- xy_grid
#save_list$realdata <- migpd_obj$data
save_list$realdata <- mexDep_spatial_obj_pred_8$data$real
save_list$proposed_coefficients <- mexDep_spatial_obj$dependence$coefficients
save_list$proposed_loglik <- mexDep_spatial_obj$dependence$loglik
save_list$HT_coefficients <- mexDep_imsi$dependence$coefficients
save_list$HT_loglik <- mexDep_spatial_obj$dependence$loglik
save_list$is_aniso <- mexDep_spatial_obj$dependence$aniso
save_list$fct_alpha <- mexDep_spatial_obj$dependence$nonlinear.obj$fct_alpha
save_list$fct_bet <- mexDep_spatial_obj$dependence$nonlinear.obj$fct_bet
save_list$fct_sigm <- mexDep_spatial_obj$dependence$nonlinear.obj$fct_sigm
save_list$fct_mu <- mexDep_spatial_obj$dependence$nonlinear.obj$fct_mu
save_list$alpha_vec <- mexDep_spatial_obj$dependence$alpha
save_list$beta_vec <- mexDep_spatial_obj$dependence$beta
save_list$modelbeta <- mexDep_spatial_obj$dependence$modelbeta
save_list$spatialmethod <- mexDep_spatial_obj$dependence$spatialmethod
save_list$par_names <- mexDep_spatial_obj$dependence$par.names
save_list$Sigma_mat <- mexDep_spatial_obj$dependence$Sigma_mat
save_list$Sigma_mat_extended <- mexDep_spatial_obj$dependence$Sigma_mat_extended
save_list$proposed_8 <- mexDep_spatial_obj_pred_8$data$simulated
save_list$proposed_9 <- mexDep_spatial_obj_pred_9$data$simulated
save_list$proposed_95 <- mexDep_spatial_obj_pred_95$data$simulated
save_list$proposed_99 <- mexDep_spatial_obj_pred_99$data$simulated
save_list$HT_8 <- mexDep_imsi_pred_8$data$simulated
save_list$HT_9 <- mexDep_imsi_pred_9$data$simulated
save_list$HT_95 <- mexDep_imsi_pred_95$data$simulated
save_list$HT_99 <- mexDep_imsi_pred_99$data$simulated
save_list$CANGRD_8 <- CANGRD_mexDep_imsi_pred_8$data$simulated
save_list$CANGRD_9 <- CANGRD_mexDep_imsi_pred_9$data$simulated
save_list$CANGRD_95 <- CANGRD_mexDep_imsi_pred_95$data$simulated
save_list$CANGRD_99 <- CANGRD_mexDep_imsi_pred_99$data$simulated
setwd("~/Dropbox/Github/paper-EDrought/prediction")
saveRDS(save_list, file=paste(save_name, '.RDS', sep=""))
}
########################################
#Step 8: joint exceedance prob plot
########################################
g <- ggplot(mexDep_spatial_obj_pred ,plot.=FALSE)
exceedance_unconditioning <- 1
unconditioning_names <- names(mexDep_imsi_pred$data$simulated)[-1][exceedance_unconditioning]
j4 <- JointExceedanceCurve(mexDep_spatial_obj_pred,0.005,which=c(central_name, unconditioning_names))
j5 <- JointExceedanceCurve(mexDep_spatial_obj_pred,0.002,which=c(central_name, unconditioning_names))
j6 <- JointExceedanceCurve(mexDep_spatial_obj_pred,0.001,which=c(central_name, unconditioning_names))
g[[exceedance_unconditioning]] +
geom_jointExcCurve(j4,aes(`central_name`, `unconditioning_names`),col="purple") +
geom_jointExcCurve(j5,aes(`central_name`, `unconditioning_names`),col="purple") +
geom_jointExcCurve(j6,aes(`central_name`, `unconditioning_names`),col="purple")
g[[exceedance_unconditioning]] +
geom_jointExcCurve(j4,aes(`-109=51`, `-115=50`),col="purple") +
geom_jointExcCurve(j5,aes(`-109=51`, `-115=50`),col="purple") +
geom_jointExcCurve(j6,aes(`-109=51`, `-115=50`),col="purple")
########################################
#Step 8: spatial joint exceedance prob plot
########################################
mexDep_spatial_obj_pred
mexDep_spatial_obj_pred$data$simulated
mexDep_spatial_obj_pred$data$pth
ExceedanceProb <- 0.05
#항상 1번이 conditioned variable
mexDep_spatial_obj_pred$data$simulated[,1]
marg_quantile <- apply(mexDep_spatial_obj_pred$data$simulated, 2, quantile, prob=1-ExceedanceProb)
exceed_index <- which(mexDep_spatial_obj_pred$data$simulated[,1]>quantile(mexDep_spatial_obj_pred$data$simulated[,1], prob=1-ExceedanceProb))
exceed_ratio <- c()
for(ii in 1:ncol(mexDep_spatial_obj_pred$data$simulated)){
exceed_ratio <- c(exceed_ratio, sum(mexDep_spatial_obj_pred$data$simulated[exceed_index,ii]>=marg_quantile[ii])/length(exceed_index))
}
h_vec_new <- c(0, h_pairwise_vec)
conditional_smooth_fit <- smooth.spline(x=h_vec_new, y=exceed_ratio, cv=FALSE)
par(mfrow=c(1,1))
par(mar= c(5.1, 4.1, 4.1, 2.1))
plot(h_vec_new, rep((0.05), length(h_vec_new)), xlab="h (separation)", ylab="Joint exceedance prob.", type="l", ylim=c(0.05, 1))
lines(conditional_smooth_fit, col="purple")
points(h_vec_new, exceed_ratio, col=2)
legend("topright", c("Independent Prob.", "Joint Prob."), col=c("black", "purple"), lty=c(1,1))
